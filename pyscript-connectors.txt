#!/usr/bin/env python
# coding: utf-8

# In[7]:

import pandas as pd
import numpy as np
import re
import os
import glob
from imbox import Imbox # pip install imbox
import traceback
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders
import config
import time
from datetime import date
from telnetlib import Telnet
from zipfile import ZipFile
import subprocess
import paramiko
import concurrent.futures
import sys

# start = time.perf_counter()
# file_name = f'Acceptance_Report_{date.today()}.xlsx'
# cols=['IP','Acceptance','rau_status','sbl_status','rau_sw','sbl','AAA_Completed','licence_status','lic_mode']

class Pymltn:
    '''Pymltn is a class that comprises of several methods used in retrieving and configuring Minilink microwave items.\n\n    Methods include both read, write and parsing functions.'''
    
    @staticmethod
    def get_inventory(hosts=None, commands=None):
        '''This method may take no argument but requires that an hosts.txt file (containing device IPs) exists \n\n\
        in the same directory from which this module is run.\n\n\
        To specicy dirrent hosts or commands from what is present in directory, provide hosts list and commands list as argument\n\n\
        E.g     get_inventory()  #uses hosts-commands file in directory\n\n\
        E.g     get_inventory(hosts=host_list, commands=command_list)  #uses hosts-commands file in directory'''
        
        results = []
        default =[]
        not_aaa_enabled=[]
        no_connectivity=[]
        unknown_error=[]
        auth_failure=[]
        p1 = b'ser'
        p2 = b'word'
        p3 = b'>'
        p4 = b'fig)#'
        
#         verifify_comm = ['show version', 'show rl revision']   
        if not hosts:
            try:
                with open(os.getcwd()+'\\hosts.txt') as f:
                    hosts = list(set([i.strip() for i in f.readlines()]))#...............check
            except:
                print('Error importing host file. Please, check if hosts.txt file exists in main directory')
                sys.exit(1)
        else:
            hosts = hosts
            
        if not commands:
            try:
                with open(os.getcwd()+'\\commands.txt') as f:
                    commands = [i.strip() for i in f.readlines()]
            except:
                print('Error importing commands file. Make sure commands.txt file exists in main directory')            
                sys.exit(2)
        else:
            commands = commands
            
        print(f'Audit in progress for: {len(hosts)} hosts ......')
        def run_comm_aaa(host):
            try:
                s = Telnet(host)
                s.read_until(p1)
                s.write(config.RADIUS_USER)
                s.read_until(p2)
                s.write(config.RADIUS_PASS)

                for comm in commands:
                    s.write(comm.encode('ascii')+b'\n')
#                     s.read_until(p3)
                time.sleep(2)
                s.write(b'exit\n')
                data = s.read_all().decode('utf-8', 'ignore')#.split('\r\n')
#                 print(data.split('\n'))#..................................check2
                
                if 'access refused' in data:
                    not_aaa_enabled.append(host)
                    return
                
                else:
                    results.append((host,'aaa',data))
                    return

            except EOFError:
                not_aaa_enabled.append(host)
            except TimeoutError:
                no_connectivity.append(host)
            except Exception:
                unknown_error.append(host)
            return
        
        
        def run_comm(host):
            try:
                s = Telnet(host)
                s.read_until(p2,1)
                s.write(config.MLTN_PASS)

                for comm in commands:
                    s.write(comm.encode('ascii')+b'\n')
#                     s.read_until(p3)
                    time.sleep(2)
                s.write(b'exit\n')
                data = s.read_all().decode('utf-8', 'ignore')#.split('\r\n')
#                 print(data.split('\n'))#..................................check2
                
                if 'access refused' in data:
                    default.append(host)
                    return
                
                else:
                    results.append((host,'not_aaa',data))
                    return

            except Exception:
                default.append(host)
            return

        def run_comm_default(host):
            try:
                s = Telnet(host)
                s.read_until(p2,3)
                s.write(config.MLTN_DEFAULT)

                for comm in commands:
                    s.write(comm.encode('ascii')+b'\n')
#                     s.read_until(p3)
                    time.sleep(2)
                s.write(b'exit\n')
                data = s.read_all().decode('utf-8', 'ignore')#.split('\r\n')
#                 print(data.split('\n'))#..................................check2
                
                if 'access refused' in data:
                    auth_failure.append(host)
                    return
                
                else:
                    results.append((host,'default',data))
                    return

            except Exception:
                unknown_error.append(host)
            return
        
        
        with concurrent.futures.ThreadPoolExecutor() as executor:
            res = executor.map(run_comm_aaa, hosts)
            all_res = [i for i in res]
                    

        if not_aaa_enabled:
            with concurrent.futures.ThreadPoolExecutor() as executor:
                res = executor.map(run_comm, not_aaa_enabled)
                all_res = [i for i in res]

        if default:
            with concurrent.futures.ThreadPoolExecutor() as executor:
                res = executor.map(run_comm_default, default)
                all_res = [i for i in res]
   
        
        return {'results':results,'no_connectivity':no_connectivity,'auth_failure':auth_failure,'unknown_error':unknown_error}
# .....................................................................................................................        


    @staticmethod
    def get_inventory_ml6600(cred=None, payload=None):
        '''This method may take no argument but requires that an hosts.txt file (containing device IPs) exists \n\n\
        in the same directory from which this module is run.\n\n\
        To specicy dirrent hosts or commands from what is present in directory, provide hosts list and commands list as argument\n\n\
        E.g     get_inventory()  #uses hosts-commands file in directory\n\n\
        E.g     get_inventory(hosts=host_list, commands=command_list)  #uses hosts-commands file in directory'''

        results = []
        default =[]
        not_aaa_enabled=[]
        no_connectivity=[]
        unknown_error=[]
        auth_failure=[]
        p1 = b'ser'
        p2 = b'word'
        p3 = b'>'
        p4 = b'fig)#'
        p5 = b'level>>'

    #     commands = ['show license status', 'show license']
        if not cred:
            cred = (config.ML6600_USER, config.ML6600_PASS)

        if not payload:
            try:
                with open(os.getcwd()+'\\commands.txt') as f:                
                    commands = [i.strip() for i in f.readlines()]
                with open(os.getcwd()+'\\hosts.txt') as f:                
                    payload = [(i.strip(), commands) for i in f.readlines()]
            except:
                print('Error importing commands file. Make sure commands.txt file exists in main directory')            
                sys.exit(2)

        print(f'Audit in progress for: {len(payload)} hosts ......')
        def run_comm(x):
            try:
                s = Telnet(x[2])

                index, m, output = s.expect([p1, p2])
                if index==0:
                    s.write(x[0])
                    s.read_until(p2)
                    s.write(x[1])

                else:
                    s.write(config.MLTN_PASS)
                    index, m, output = s.expect([p2, p3])
                    if index==1:
                        s.write('enable'.encode('ascii')+b'\n')
                        s.read_until(p2)
                        s.write(config.MLTN_PASS)
                    else:
                        s.write(config.MLTN_DEFAULT)
                        s.read_until(p3)
                        s.write('enable'.encode('ascii')+b'\n')
                        s.read_until(p2)
                        s.write(config.MLTN_PASS)

                for comm in x[3]:
                    time.sleep(1)
                    s.write(comm.encode('ascii')+b'\n')
                    time.sleep(1.5)
                s.write(b'exit\n')
                data = s.read_all().decode('utf-8', 'ignore')#.split('\r\n')
    #                 print(data.split('\n'))#..................................check2

                if 'ERROR' in data:
                    not_aaa_enabled.append((x[2],x[3]))
                    return

                else:
                    results.append((x[2],x[0],data))
                    return

            except EOFError:
                not_aaa_enabled.append((x[2],x[3]))
            except TimeoutError:
                no_connectivity.append((x[2],x[3]))
            except Exception:
                unknown_error.append((x[2],x[3]))
            return


        hosts_tuple1 =[(cred[0],cred[1], i[0], i[1]) for i in payload]
        with concurrent.futures.ThreadPoolExecutor() as executor:
            res = executor.map(run_comm, hosts_tuple1)
            all_res = [i for i in res]


        if not_aaa_enabled:
            cred = (config.RADIUS_USER, config.RADIUS_PASS)
            hosts_tuple1 =[(cred[0],cred[1],i[0], i[1]) for i in not_aaa_enabled]
            with concurrent.futures.ThreadPoolExecutor() as executor:
                res = executor.map(run_comm, hosts_tuple1)
                all_res = [i for i in res]


        return {'results':results,'no_connectivity':no_connectivity,'auth_failure':auth_failure,'unknown_error':unknown_error}

    # get_inventory_ml6600()

    
#........................................................................................................................    

    @staticmethod
    def get_status_and_command():
        
        no_connectivity=[]
        unknown_error=[]
        auth_failure=[]
        temp_conn_issue=[]
        
        try:
            with open(os.getcwd()+'/hosts.txt') as f:
                hosts = list(set([i.strip() for i in f.readlines()]))#...............check
        except:
            print('Error importing host file. Please, check if hosts.txt file exists in main directory')
            sys.exit(1)
        try:
            with open('keys.txt') as f:
                keys = list(set([i.strip() for i in f.readlines()]))
        except:
            print('Error importing key file. Make sure keys.txt file exists in main directory')
            sys.exit(2)

        output=Pymltn.get_inventory(commands=['show license status'])

        if output['no_connectivity']: no_connectivity.extend(output['no_connectivity'])
        if output['auth_failure']: auth_failure.extend(output['auth_failure'])
        if output['unknown_error']: unknown_error.extend(output['unknown_error'])

        data2 = output['results']
        try:
            status_2=[(i[0],i[1], Pymltn.cli_parse(i[2]).get('NE License Status','unknown')) for i in data2]
            data =[(i[0],i[1], Pymltn.cli_parse(i[2]).get('RMM fingerprint','unknown')) for i in data2]
            host_status = {i[0]: Pymltn.cli_parse(i[2]).get('NE License Status','unknown') for i in data2}
            host_command = [(i[0],i[1],f'license install {j}') for i in data for j in keys if i[2] in j and host_status[i[0]]!='Ok']
            upload_command = [(i[0],i[1],f'upload file {i[0]}_LRF.xml') for i in status_2 if i[2]!='Ok']

        except:
            return ('unknown','unknown','unknown')
        print(status_2)
        if len({i[2] for i in status_2})==1 and list({i[2] for i in status_2})[0]=='Ok':
            if no_connectivity:
                print('*'*90)
                print(f'no_connectivity: {no_connectivity}')
            sys.exit("NO action required - All licenses are upto date")
        return host_command,upload_command


# ........................................................................................................................

    @staticmethod
    def install_license(com_data):
        host,session_type,command = com_data
        
        no_connectivity=[]
        unknown_error=[]
        auth_failure=[]
        temp_conn_issue=[]
        
        p1 = b'ser'
        p2 = b'word'
        p3 = b'>'
        p4 = b'#'

    #     print(f'Installation in progress  ......')

        if session_type=='aaa':
            prompt = p3
            try:
                s = Telnet(host)
    #             print(f'connected to {host}')
            except:
                temp_conn_issue.append(host)
                return

            s.read_until(p1)
            s.write(config.RADIUS_USER)
            s.read_until(p2)
            s.write(config.RADIUS_PASS)
            time.sleep(1)

            try:
                if upload:
                    s.write(b'license request\n')
                    time.sleep(1)
                s.write(command.encode()+b'\n')
                s.read_until(prompt)#time.sleep(1)

                s.write(b'exit\n')
                s.write(b'exit\n')
                x=s.read_all()     #x=s.read_until(b'ffff')
                if 'upload is started' in x:
                    results.append((host, "uploaded"))
                elif 'background' in x:
                    results.append((host, "installed"))
                    return
            except:
                unknown_error.append(host)
                return

        elif session_type=='not_aaa':
            prompt = p4
            try:
                s = Telnet(host)
    #             print(f'connected to {host}')
            except:
                temp_conn_issue.append(host)
                return
            s.read_until(p2)
            s.write(config.MLTN_PASS)
            s.read_until(p3)
            s.write(b'enable\n')
            s.read_until(p2)
            s.write(config.MLTN_PASS)
            s.read_until(prompt)
            s.write(b'enable user admin_user\n')
            s.read_until(p2)
            s.write(config.MLTN_DEFAULT)
            s.read_until(p4)
            try:
                if upload:
                    s.write(b'license request\n')
                    time.sleep(1)
                s.write(command.encode()+b'\n')
                s.read_until(prompt)#time.sleep(1)      
                s.write(b'exit\n')
                s.write(b'exit\n')
                x=s.read_all()     #x=s.read_until(b'ffff')
                if 'upload is started' in x:
                    results.append((host, "uploaded"))
                elif 'background' in x:
                    results.append((host, "installed"))
                    return
            except:
                unknown_error.append(host)
                return

        elif session_type=='default':
            prompt = p4
            try:
                s = Telnet(host)
    #             print(f'connected to {host}')
            except:
                temp_conn_issue.append(host)
                return
            s.read_until(p2)
            s.write(config.MLTN_DEFAULT)
            s.read_until(p3)
            s.write(b'enable\n')
            s.read_until(p2)
            s.write(config.MLTN_DEFAULT)
            s.read_until(prompt)
            s.write(b'enable user admin_user\n')
            s.read_until(p2)
            s.write(config.MLTN_DEFAULT)
            s.read_until(p4)
            try:
                if upload:
                    s.write(b'license request\n')
                    time.sleep(1)
                s.write(command.encode()+b'\n')
                s.read_until(prompt)#time.sleep(1)      
                s.write(b'exit\n')
                s.write(b'exit\n')
                x=s.read_all().decode()     #x=s.read_until(b'ffff')
                if 'upload is started' in x:
                    results.append((host, "uploaded"))
                elif 'background' in x:
                    results.append((host, "installed"))
                    return
            except:
                unknown_error.append(host)
                return
        return


# ..........................................................................................................................
    
    @staticmethod
    def restart_node(com_data):
        host,session_type,command = com_data
        p1 = b'ser'
        p2 = b'word'
        p3 = b'>'
        p4 = b'#'

    #     print(f'Installation in progress  ......')

        if session_type=='aaa':
            prompt = p3
            try:
                s = Telnet(host)
    #             print(f'connected to {host}')
            except:
                temp_conn_issue.append(host)
                return

            s.read_until(p1)
            s.write(config.RADIUS_USER)
            s.read_until(p2)
            s.write(config.RADIUS_PASS)
            time.sleep(1)
            s.write(command.encode()+b'\n')
            s.read_until(prompt)#time.sleep(1)
            print(f'{host} restarted')
            s.write(b'exit\n')
            s.write(b'exit\n')        
    #         try:
    #             if upload:
    #                 time.sleep()
    #                 s.write(b'license request\n')
    #                 time.sleep(1)
    #             s.write(command.encode()+b'\n')
    #             s.read_until(prompt)#time.sleep(1)

    #             s.write(b'exit\n')
    #             s.write(b'exit\n')
    #             x=s.read_all()     #x=s.read_until(b'ffff')
    #             if 'upload is started' in x:
    #                 results.append((host, "uploaded"))
    #             elif 'background' in x:
    #                 results.append((host, "installed"))
    #                 return
    #         except:
    #             unknown_error.append(host)
    #             return

        elif session_type=='not_aaa':
            prompt = p4
            try:
                s = Telnet(host)
    #             print(f'connected to {host}')
            except:
                temp_conn_issue.append(host)
                return
            s.read_until(p2)
            s.write(config.MLTN_PASS)
            s.read_until(p3)
            s.write(b'enable\n')
            s.read_until(p2)
            s.write(config.MLTN_PASS)
            s.read_until(prompt)
            s.write(command.encode()+b'\n')
            s.read_until(prompt)
            print(f'{host} restarted')
            s.write(b'exit\n')
            s.write(b'exit\n')
    #         s.write(b'enable user admin_user\n')
    #         s.read_until(p2)
    #         s.write(config.MLTN_DEFAULT)
    #         s.read_until(p4)
    #         try:
    #             if upload:
    #                 s.write(b'license request\n')
    #                 time.sleep(1)
    #             s.write(command.encode()+b'\n')
    #             s.read_until(prompt)#time.sleep(1)      
    #             s.write(b'exit\n')
    #             s.write(b'exit\n')
    #             x=s.read_all()     #x=s.read_until(b'ffff')
    #             if 'upload is started' in x:
    #                 results.append((host, "uploaded"))
    #             elif 'background' in x:
    #                 results.append((host, "installed"))
    #                 return
    #         except:
    #             unknown_error.append(host)
    #             return

        elif session_type=='default':
            prompt = p4
            try:
                s = Telnet(host)
    #             print(f'connected to {host}')
            except:
                temp_conn_issue.append(host)
                return
            s.read_until(p2)
            s.write(config.MLTN_DEFAULT)
            s.read_until(p3)
            s.write(b'enable\n')
            s.read_until(p2)
            s.write(config.MLTN_DEFAULT)
            s.read_until(prompt)
            s.write(command.encode()+b'\n')
            s.read_until(prompt)
            print(f'{host} restarted')
            s.write(b'exit\n')
            s.write(b'exit\n')
    #         s.write(b'enable user admin_user\n')
    #         s.read_until(p2)
    #         s.write(config.MLTN_DEFAULT)
    #         s.read_until(p4)
    #         try:
    #             if upload:
    #                 s.write(b'license request\n')
    #                 time.sleep(1)
    #             s.write(command.encode()+b'\n')
    #             s.read_until(prompt)#time.sleep(1)      
    #             s.write(b'exit\n')
    #             s.write(b'exit\n')
    #             x=s.read_all().decode()     #x=s.read_until(b'ffff')
    #             if 'upload is started' in x:
    #                 results.append((host, "uploaded"))
    #             elif 'background' in x:
    #                 results.append((host, "installed"))
    #                 return
    #         except:
    #             unknown_error.append(host)
    #             return
        return


# ............................................................................................................................

    @staticmethod    
    def the_parser(x):
        
        if 'access refused' in x[2]:
            return [x[0]]
        else:
            try:
                licence_status = [line.split(':')[1].strip() for line in x[2].split('\n') if 'NE License Status:' in line]
                licence_mode = [line.split(':')[1].strip() for line in x[2].split('\n') if 'NE License Mode:' in line]
                rau_sw = [line.split(':')[1].strip() for line in x[2].split('\n') if 'RAU - active' in line]
                sbl = [line.split(':')[-1].strip() for line in x[2].split('\n') if ('Active SBL' in line or 'BNS' in line) and not 'Active BNS' in line]
                rau_status = 'Failed' if 1!=len(set(rau_sw)) or list(set(rau_sw))[0]!='R5E01' else 'Passed'
                sbl_status = 'Failed' if not '5.4FP.5 LH 1.6FP.5_R33G124' in sbl[0] else 'Passed'
                acceptance = 'Passed' if rau_status=='Passed' and sbl_status=='Passed' else 'Failed'
    #             license = 'Passed' if licence_status.lower()=='ok' and licence_mode.lower()=='locked' else 'Failed'
                #results.append((host,acceptance,rau_status,sbl_status,rau_sw,sbl[0].split(' - ')[0],'NO'))

                return (x[0],acceptance,rau_status,sbl_status,rau_sw,sbl[0].split(' - ')[0],x[1],licence_status[0],licence_mode[0])
            except:
                if 'Invalid Command' in x[2]:
                    sbl = [line.split('CXCR:')[-1].strip() for line in x[2].split('\n') if 'CXCR:' in line]
                    sbl_status = 'Failed' if not '5.4FP.5 LH 1.6FP.5_R33G124' in sbl[0] else 'Passed'
                    acceptance = 'Passed' if rau_status=='Passed' and sbl_status=='Passed' else 'Failed'
                    return (x[0],acceptance,'unknown',sbl_status,'unknown',sbl[0].split(' - ')[0],x[1],'unknown','unknown')
#                     print(f'{x[0]}: Error while parsing data. ....check the_parser')
                else:
                    return (x[0],'unknown','unknown','unknown','unknown','unknown','unknown','unknown','unknown')

# ----------------------------------------------------------------------------------------------------------------------------------        
    @staticmethod
    def ping(hosts_test_file):
        """device_ping is a ping function that takes a list argument of IP_Addresses/hosts \
        and an optional boolean file argument which when passed, returns a file object instead of\
        a list of hosts and current status. When called without the optional argument, defaults to 'file=True'\n\n\
        Example:\n\naddress_list = ['172.8.8.8', '8.8.8.8', '192.168.0.152']\n\ndevice_ping(address_list)"""
        
        with open(hosts_test_file, 'r') as f:
            hosts = list(set([i.strip() for i in f.readlines()]))

        def device_ping(device):

            command = f'ping -n 2 -w 2 {device}'
            try:
                k = subprocess.run(command, shell=True, capture_output=True, text=True)
                output = k.stdout

                if f"Reply from {device}: bytes=32 time=" in output:
                    return (device,'succeeded')

                elif 'Request timed out' in output:
                    return (device,'timed out')

                elif 'unreachable' in output:
                    return (device,'unreachable')

                else:
                    return (device,'unknown')

            except Exception as e:
                return (device, e)

        with concurrent.futures.ThreadPoolExecutor() as executor:
            res = executor.map(device_ping, hosts)
            all_res = [i for i in res]
        report_file='Ping_Report.xlsx'
        pd.DataFrame(all_res, columns=['Devices','Status']).to_excel(report_file, index=False)
        return report_file


#-----------------------------------------------------------------------------------------------------------------------------------
    @staticmethod 
    def sftp(method, file):

        remotepath = f'/nbupool/sftp-minilink/{file}'
        localpath = f'{os.getcwd()}\\{file}'
        transport = paramiko.Transport(('172.21.59.38',22))
        transport.connect(None, 'sftp-minilink', 'mini1ink')
        sftp = paramiko.SFTPClient.from_transport(transport)

        if method=='get':
            sftp.get(remotepath, localpath) #download
            status = 'File succefully Transfered' if os.path.exists(localpath) else 'File Tranfer Failed'
            print(status)

        elif method=='put':
            sftp.put(localpath, remotepath) #upload
        if sftp: sftp.close()   
        if transport: transport.close()

    # sftp('get', '172.30.114.169_77334501110e2037cf0a0a20_LRF.xml')


# ---------------------------------------------------------------------------------------------------------------------------    

    @staticmethod
    def cli_parse(h):
        '''This module parses cli outputs and stores as a python object for easier accessibility\n\n\
        E.G cli_parse(output)'''
        h1 = h.split('\n')
        h2 = [line.strip('\r') for line in h1 if line!='\r' or line!='\r\r' or not '>' in line or not '#' in line or line!='']
        h3 = {(i.split(':')[0].strip()):("".join(i.split(':')[1:])) for i in h2}
        h4=[i for i in list(h3.items()) if i[0]!="" and not '>' in i[0] and not '#' in i[0]]
        return {i[0]:i[1].strip() for i in h4}
    # cli_parse(h)

# ---------------------------------------------------------------------------------------------------------------------------------    

    @staticmethod
    def license_sftp(method, file_name):
        '''Allows for files transfer to and from remote sftp server using below synopsis\n\n\
        E.g   To fetch files from sftp server, use:  license_sftp('get', '_LRF.xml') \n\n\
              To send files to sftp server, use:  license_sftp('put', '_LRF.xml')'''

        transport = paramiko.Transport(('172.21.59.38',22))
        transport.connect(None, 'sftp-minilink', 'mini1ink')
        sftp = paramiko.SFTPClient.from_transport(transport)
    #     print(sftp.listdir())

        if method=='get':
            remote_files = [x for x in sftp.listdir() if file_name in x]
            for file in remote_files:
                localpath = f'{os.getcwd()}\\{file}'
                remotepath = f'/nbupool/sftp-minilink/{file}'
                sftp.get(file, localpath) #download all
                time.sleep(0.3)
                status = 'File successfully Transfered' if os.path.exists(localpath) else None#'File Tranfer Failed'
                if status:
                    sftp.remove(file)
                else:             
                    print(f'{file} not moved')
            print('File Transfer succeeded!')
            zippedFile= 'zippedFile.zip'    
            with ZipFile(zippedFile, 'w') as f:    
                [f.write(i) for i in glob.glob('*'+file_name)]
            [os.remove(i) for i in glob.glob('*'+file_name)]
            return zippedFile

        elif method=='put':
            local_files = [x for x in os.listdir() if file_name in x]
            for file in local_files:
                localpath = f'{os.getcwd()}\\{file}'
                remotepath = f'/nbupool/sftp-minilink/{file}'
                sftp.put(localpath,remotepath) #upload all
                time.sleep(0.3)
                status = 'File successfully Transfered' if file in sftp.listdir() else None#'File Tranfer Failed'
                if status:
                    sftp.remove(file)
                else:             
                    print(f'{file} not moved')
            print('File Transfer succeeded!')
            return 

#     my_email_sender(license_sftp('get', '_LRF.xml'))
        # license_sftp('get', '_LRF.xml')

# ----------------------------------------------------------------------------------------------------------------------------

    @staticmethod
    def my_email_sender(files):
        """This function takes two list_arguments: First is to_list which is the list of receiver's email addresses\n    and second is the f_list: list of files(absolute path) to be sent.\n\nExample: \n    f_list = [os.getcwd()+'\\sw_trial_1.xlsx', C:\\Users\\user\\SW_remote_inventory.xlsx]\n\n       my_email_sender(f_list)"""

        try:

            msg = MIMEMultipart()
        #     msg['Subject'] = 'Bitcoin Price Notification'
            msg['Subject'] = 'Microwave Report'
            msg['From'] = config.EMAIL_ADDRESS
            msg['To'] = config.EMAIL_ROGERS
            body = "Please find attached Microwave report."

            msg.attach(MIMEText(body, 'plain'))

    #         with open(file, 'rb') as f:
    #         attachment = file
    #         file_name = file.name
            for file in files:
                base = MIMEBase('application', 'octet-stream')
                base.set_payload(open(file, "rb").read())
                encoders.encode_base64(base)
                base.add_header('content-Disposition', 'attachment', filename=file)
                msg.attach(base)

            with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
                smtp.login(config.EMAIL_ADDRESS, config.APP_PASSWORD)

                smtp.send_message(msg)
        except Exception as e:
            print(e)
    #         print('Error while trying to send email')

        return
    # file_name=f'{os.getcwd()}\\hosts.txt'
    # my_email_sender(file_name)
    
    
# ---------------------------------------------------------------------------------------------------------------------------#    
        # df['Country (region)'].str.extract(r'(^w{5})') For regular expression

    @staticmethod
    def fetch_imt_hosts(imt_file):
        def extract(g):
            try:
                a = re.search('mw-.{5,6}\d{2}',g).group(0)
                return a
            except:
                return 'NAN'
        try:
            lookup = pd.read_csv('mltn_all.csv')
            lookup['Hostname']=lookup['Hostname'].str.lower()


            data = pd.read_excel(imt_file)[1:]
            data=data[['Unnamed: 1','Unnamed: 10','Unnamed: 11']]
            data['Unnamed: 10'],data['Unnamed: 11']=data['Unnamed: 10'].str.lower(),data['Unnamed: 11'].str.lower()
            data['new'] = data['Unnamed: 10'].apply(extract)
            data['new1'] = data['Unnamed: 11'].apply(extract)
            data['new']=np.where(data['new']=='NAN', data['new1'],data['new'])
            data=data[['Unnamed: 1','new']]
            data=data[data.new.str.contains('mw')]
            data.columns=['imt','Hostname']
            report = data.merge(lookup[['Hostname','Management Address','System Location']], how='left', on='Hostname')
            return list(lookup['Management Address'])
        except:
            print('Error: Unable to process')
    # fetch_imt_hosts('imt.xlsx')

    # -------------------------------------------------------------------------------------------------------------

    @staticmethod
    def fetch_etac_imt():
        lookup = pd.read_csv('mltn_all.csv')
        lookup['Hostname']=lookup['Hostname'].str.lower()
        if os.path.exists('Equipment TAC IMTs_V5.xlsx'):
            data=pd.read_excel('Equipment TAC IMTs_V5.xlsx', sheet_name='ETAC Assigned IMT')
            data.columns=data.iloc[0]
            data=data.drop(0,0)
            data = data[data.State!='Closed']
            data=data[data.Summary.str.contains('License')].drop_duplicates(subset=['Imt Id'])
            data=data[['Imt Id','IMT Com Networkelement.Element', 'Site','Region']]
            data.columns=['Imt','Hostname', 'Site','Region']
            data['Hostname']=data.Hostname.str.lower()
            report = data.merge(lookup[['Hostname','Management Address','System Location']], how='left', on='Hostname')
            return report
        else:
            print('Equipment TAC IMTs_V5.xlsx does not exist')
            sys.exit(-1)
    # fetch_etac_imt()

    # # -----------------------------------------------------------------------------------------------------

    @staticmethod
    def download_file(file_name):
        '''Download specified file from Gmail based on subject and date\n\n\
        # download_file('Equipment TAC IMTs_V5')\n\n\
        # enable less secure apps on your google account\n\n\
        # https://myaccount.google.com/lesssecureapps\n\n\
        Available Message filters: 

        # Gets all messages from the inbox
        messages = mail.messages()
        # Unread messages
        messages = mail.messages(unread=True)
        # Flagged messages
        messages = mail.messages(flagged=True)
        # Un-flagged messages
        messages = mail.messages(unflagged=True)
        # Flagged messages
        messages = mail.messages(flagged=True)
        # Un-flagged messages
        messages = mail.messages(unflagged=True)
        # Messages sent FROM
        messages = mail.messages(sent_from='sender@example.org')
        # Messages sent TO
        messages = mail.messages(sent_to='receiver@example.org')
        # Messages received before specific date
        messages = mail.messages(date__lt=datetime.date(2018, 7, 31))
        # Messages received after specific date
        messages = mail.messages(date__gt=datetime.date(2018, 7, 30))
        # Messages received on a specific date
        messages = mail.messages(date__on=datetime.date(2018, 7, 30))
        # Messages whose subjects contain a string
        messages = mail.messages(subject='Christmas')
        # Messages from a specific folder
        messages = mail.messages(folder='Social')
        '''

        host = "imap.gmail.com"
        username = config.EMAIL_ADDRESS
        password = config.PYTHON_EMAIL_PASSWORD
        download_folder = os.getcwd()

        # if not os.path.isdir(download_folder):
        #     os.makedirs(download_folder, exist_ok=True)

        mail = Imbox(host, username=username, password=password, ssl=True, ssl_context=None, starttls=False)
        # messages = mail.messages() # defaults to inbox
        # messages = mail.messages(sent_from=config.RECEIVER)
        messages = mail.messages(date__on=date.today())

        for (uid, message) in messages:
        #     mail.mark_seen(uid) # optional, mark message as read
            for idx, attachment in enumerate(message.attachments):
                try:
                    att_fn = attachment.get('filename')
                    if file_name in att_fn:
                        download_path = f"{download_folder}/{att_fn}"
    #                     print(download_path)
                        with open(download_path, "wb") as f:
                            f.write(attachment.get('content').read())
                except:
                    print(traceback.print_exc())
                    return False
        mail.logout()
        for file in os.listdir():
            if file_name in file:
                file_name=file
        return os.path.exists(file_name)

    # download_file('Equipment TAC IMTs_V5')
    
    
# ------------------------------------------------------------------------------------------------------------------------
    
    @staticmethod
    def get_licence_status():
        '''This module generates a license report from Remedy IMT report.\n\n\
        It takes no argument but expects both Remedy IMT report & mtn_all (NNMI mltn csv).\n\n\
        Sends a mail of the report while also returning a LIST of hosts that need LRFs to be generated.'''

        file=f'License_IMT_Report_{date.today()}.xlsx'
        data = Pymltn.fetch_etac_imt()
        ips = list(data.dropna()['Management Address'])

        r = Pymltn.get_inventory(ips,['show license status'])
        no_connectivity,auth_failure,unknown_error = r['no_connectivity'],r['auth_failure'],r['unknown_error']
        
#         try:
        out = [(i[0],i[1],Pymltn.cli_parse(i[2])['NE License Status'],Pymltn.cli_parse(i[2])['RMM fingerprint']) for i in r['results'] if 'NE License Status' in i[2] and 'RMM fingerprint' in i[2]]
#         except:
#             out = [(i[0],i[1],'Unknown','Unknown') for i in r['results']]
            
        output = pd.DataFrame(out, columns=['Management Address','AAA_status','License','Fingerprint'])
        try: 
            LRF = output[output['License'].str.lower()!='ok'].merge(data, how='left', on='Management Address')
        except: LRF=None

        final = data.merge(output, how='left', on='Management Address')
        with pd.ExcelWriter(file) as writer:
            final.to_excel(writer, sheet_name='Report',index=False)
            if len(LRF):
                LRF.to_excel(writer, sheet_name='LKF_Request', index=False)
            if no_connectivity:
                no_c=pd.DataFrame(no_connectivity,columns=['Management Address']).merge(output, how='left', on='Management Address')
                no_c.to_excel(writer, sheet_name='no_connectivity', index=False)
            if unknown_error:
                unk=pd.DataFrame(unknown_error,columns=['Management Address']).merge(output, how='left', on='Management Address')
                unk.to_excel(writer, sheet_name='unknown_error', index=False)
            if auth_failure:
                auth=pd.DataFrame(auth_failure,columns=['Management Address']).merge(output, how='left', on='Management Address')
                auth.to_excel(writer, sheet_name='auth_failure', index=False)

        try:
            Pymltn.my_email_sender(file)
        except:
            print('Problem sending email')     
        return [(a,b) for a,b in zip(LRF['Management Address'],LRF['Fingerprint'])]

# get_licence_status()


# ----------------------------------------------------------------------------------------------------------------------
#     import time
#     import subprocess
#     import concurrent.futures
#     import pandas as pd
#     from pymltn_sdk import Pymltn

    @staticmethod
    def port_scanner():

        port =input('What port do you want to test\n')

        with open('hosts.txt', 'r') as f:
            hosts = list(set([i.strip() for i in f.readlines()]))
            file = 'TCP_Port_Report.xlsx'

        def port_test(device):
            """device_ping is a ping function that takes a list argument of IP_Addresses/hosts \
            and an optional boolean file argument which when passed, returns a file object instead of\
            a list of hosts and current status. When called without the optional argument, defaults to 'file=True'\n\n\
            Example:\n\naddress_list = ['172.8.8.8', '8.8.8.8', '192.168.0.152']\n\ndevice_ping(address_list)"""

            command = f'nc -zvw2 {device} {port}'

            try:
                k = subprocess.run(command, shell=True, capture_output=True, text=True)
                output = k.stdout

                if "Connected" in output:
                    return (device,'Open')

                else:
                    return (device,'unknown')

            except Exception as e:
                return (device, e)

        with concurrent.futures.ThreadPoolExecutor() as executor:
            res = executor.map(port_test, hosts)
            all_res = [i for i in res]

        framed = pd.DataFrame(all_res, columns=['Devices',f'Port {port}'])
        framed.to_excel(file, index=False)
        time.sleep(3)

        Pymltn.my_email_sender([file])
        return 'Sent!'

    
#     -----------------------------------------------------------------------------------------------------------------------------
#    port_scanner()
# ------------------------------------------------------------------------------------------------------
        
    #devops journey (save this channel)
#     paramiko
    
# import config
# import pandas as pd
# from paramiko import SSHClient, AutoAddPolicy
# import concurrent.futures

   
# comm = config.LICENSE_STATUS
# with open('hosts.txt', 'r') as f:
#     hosts = [i.strip() for i in f.readlines()]

# def cisco(host):

#     try:
#         client = SSHClient()
#         client.set_missing_host_key_policy(AutoAddPolicy)
# #         help(client)
#         client.connect(host, username='cli', port=22)#, timeout=2, auth_timeout=3.0)
#     except Exception as e:
#         return {'error': (host,e)}
    
#     try:
#         stdin,stdout,stderr = client.exec_command(comm)
#     except:
#         stdin.close();stdout.close();stderr.close();client.close()
#         return {'error2': (host,"command error",stderr.read().decode())}

#     if stdout.channel.recv_exit_status()==0:
#         data = stdout.read().decode()
#         print(data)
# #             if "NTP Server" in data:
# #                 try:
# #                     servers = [i.split(':')[1].strip() for i in data.split('\n') if "NTP Server" in i]
# #                     status = [i.split(':')[1].strip() for i in data.split('\n') if "Status" in i]
# #                     servers.append("*"); servers.append("*")
# #                     status.append("*"); status.append("*")
# #                     ntp_servers= [f'{i}_{j}' for i,j in zip(servers,status)][:3]; ntp_servers.insert(0,host)
# #                     stdin.close();stdout.close();stderr.close();client.close()
# #                     return {'result': tuple(ntp_servers)}

# #                 except:
# #                     stdin.close();stdout.close();stderr.close();client.close()
# #                     return {'result': (host,data,"","")}

# #             else:
# # #                 print(data)
# #                 ntp_servers = (host,"no_ntp_config","no_ntp_config","no_ntp_config")
# #                 stdin.close();stdout.close();stderr.close();client.close()
# #                 return {'result': ntp_servers}
#     else:
#         stdin.close();stdout.close();stderr.close();client.close()
#         return {'error': (host, stderr.read().decode())}


# def main():
#     with concurrent.futures.ThreadPoolExecutor() as executor:
#         results = [i for i in executor.map(cisco, hosts[0:1])]
#     print(results)
#     return results

# if __name__=="__main__":
#     main()
# #     client = SSHClient()
# #     client.set_missing_host_key_policy(AutoAddPolicy)
# #     help(client)


# ----------------------------------------------------------------------------------------------------------
# NSLOOKUP

# from pymltn_sdk import Pymltn
# import time
# import pandas as pd
# import subprocess
# import concurrent.futures

# with open('hosts.txt', 'r') as f:
#     hosts = list(set([i.strip() for i in f.readlines()]))
# file = 'NSlookup.xlsx'


# # hosts=['172.30.114.227','172.30.114.136','ytuhju','172.30.114.137']

# def dns_lookup(host):
#     command = f'nslookup {host}'
#     try:
#         k = subprocess.run(command, shell=True, capture_output=True, text=True)
#         output = k.stdout.split('\n')[3:5]
#         output = (output[1].split(':')[1].strip(), output[0].split(':')[1].strip())
#         return output
#     except:
#         return (host, None)


# with concurrent.futures.ThreadPoolExecutor() as executor:
#     res = executor.map(dns_lookup, hosts)
#     all_res = [i for i in res]

# t = pd.DataFrame(all_res, columns=['Devices','HostName']); t.to_excel(file, index=False)
# time.sleep(2)

# Pymltn.my_email_sender([file])



# ----------------------------------------------------------------------------------------------------
# ml6352 SSH client
# -------------------------------------------------------------------------------------

# import pexpect
# import config
# import pymltn_sdk
# import pandas as pd
# import concurrent.futures


# _type = input("Press 'i' for install OR 'r' for request" +'\n')

# with open('ml6352_hosts.txt', 'r') as f:
#     hosts = set([i.strip() for i in f.readlines()])

# def cli_parse(h):
#     '''This module parses cli outputs and stores as a python object for easier accessibility'''
#     h1 = h.split('\n')
#     h2 = [line.strip('\r') for line in h1 if line!='\r' or line!='\r\r' or not '>' in line or not '#' in line or line!='']
#     h3 = {(i.split(':')[0].strip()):("".join(i.split(':')[1:])) for i in h2}
#     h4=[i for i in list(h3.items()) if i[0]!="" and not '>' in i[0] and not '#' in i[0]]
#     return {i[0]:i[1].strip() for i in h4}

# result=[]
# def run_command(host):

#     try:
#         com1 = 'show config common licenses'
#         remote_server= 'mode sftp server-ip 172.21.59.38 server-port 22 server-user sftp-minilink server-password mini1ink'
#         com5,com4 = ('end; config common licenses pre-empt-unlock', 'quit')

#         def start_session():
#             session_command =f"ssh -o StrictHostKeyChecking=no cli@{host} -o ConnectTimeout=6"
#             try:
#                 session = pexpect.spawn(session_command)
#             except:
#                 result.append((host, "connection_error",'connection_error'))
#                 return
#             return session


#         def admin_auth():
#             session.expect('login')
#             session.sendline(config.ML6352_USER)
#             session.expect('assword')
#             session.sendline(config.ML6352_PASS)
#             i = session.expect(['#', 'assword'])
#             if i==0:
#                 session.sendline(com1)
#                 session.expect('#')
#                 return session
#             else:
#                 session.sendline(config.MLTN_PASS)
#                 j = session.expect(['#', 'assword'])
#                 if j==0:
#                     session.sendline(com1)
#                     session.expect('#')
#                     return session
#                 else:
#                     session.sendline(config.MLTN_DEFAULT)
#                     k = session.expect(['#', 'assword'])
#                     if k==0:
#                         session.sendline(com1)
#                         session.expect('#')
#                         return session
#                     else:
#         #                 result.append((host, "auth_failure"))
#                         session.kill(0)
#                         return


#         def radius_auth():
#             session.expect('ser')
#             session.sendline(config.RADIUS_USER)
#             session.expect('assword')
#             session.sendline(config.RADIUS_PASS)
#             i = session.expect(['#', 'assword'])
#             if i==0:
#                 session.sendline(com1)
#                 session.expect('#')
#                 return session
#             else:
#                 result.append((host, 'radius_auth',"auth_failure"))
#                 session.kill(0)
#                 return

#         def license_com():
#             output = session.before.decode()
#             output2 = cli_parse(output)
#             status,mode,fingerprint = (output2['node-license-status'],output2['mode'],output2['fingerprint'])
#             com2 = f'end; config common licenses license-install install-license {fingerprint}.xml {remote_server}'
#             com3 = f'end; config common licenses create-upload-lrf license-request-file {fingerprint}_LRF.xml {remote_server}'

#             if status.lower()=='ok' and mode.lower()!='lock_mode':
#                 session.sendline(com5)
#                 session.expect('#')
#                 session.sendline(com4)
#                 result.append((host,'unlocked','locked'))

#             elif status.lower()=='ok' and mode.lower()=='lock_mode':
#                 session.sendline(com4)
#                 result.append((host,'ok','ok'))

#             elif status.lower()!='ok':
#                 if _type=='r':
#                     session.sendline(com3)
#                     session.expect('#')
#                     session.sendline(com4)
#                     result.append((host,status,'requested'))
#                 else:
#                     session.sendline(com2)
#                     session.expect('#')
#                     session.sendline(com4)
#                     result.append((host,status,'installing...'))
#             else:
#                 session.sendline(com4)
#                 result.append((host,'unknown','unknown'))


#         session = start_session()
#         if session:
#             session = admin_auth()
#             if session:
#                 session = license_com()
#             else:
#                 session = radius_auth()
#                 if session():
#                     session = license_com()
#     except:
#         result.append((host, "connection_error",'connection_error'))
#         return
#     return
# #...............................................................................................

# with concurrent.futures.ThreadPoolExecutor() as executor:
#     res = executor.map(run_command, hosts)
#     _ = [i for i in res]

# if result:
#     file_name = 'ml6600_license_report.xlsx'
#     results = pd.DataFrame(result, columns=['Hosts','Status','Action'])
#     results.to_excel(file_name, index=False)

#     try:
#         Pymltn.my_email_sender(file_name)
#     except:
#         print('Problem sending email')
# print(results)
